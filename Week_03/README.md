学习笔记
1. 字典树
 1.1 创建一个Trie类，新建一个root作为字典树根节点
 1.2 插入字符串时，把root赋予给局部变量node作为第一个节点，然后遍历字符串word，对每一个字符串进行比较判断node是否存在
 如果不存在，创建一个纯空对象赋予给node[c]，把node[c]重新赋值给node，以此类推
 1.3 遍历完成后，有symbol创建的$变量，判断node是否存在这个字段，如果不存在则创建并赋值为零，最后在加1，作为计数；
2. Reactive
 2.1 在获取对象字段值时，把该对象该字段收集到usedReactivities集合，并判断对象字段属性是否为对象，如果是在递归成代理响应对象
 2.2 把要代理响应的对象放到Proxy进行封装加工成代理对象，在赋值时拦截监听该对象该字段响应的回调函数
 2.3 effect函数收集要监听的回调函数，先清空usedReactivities集合，后执行callback回调函数
 2.4 在从usedReactivities集合遍历出对象和对象字段属性，后判断callbacks集合里是否存在该对象的键，没有则创建到callbacks集合里，
 在判断该对象键的值是否存在该字段属性的键，没有则创建到该对象键的值中，然后把callback回调函数push到该字段属性的键的值数组中
### KMP

子串查找的一种算法。先琢磨琢磨暴力解：

``` js
function match(source, pattern) {
  // 双指针
  let i = 0, j = 0;
  while(i < source.length) {
    // 相等
    if (source[i] === pattern[j]) {
      // 匹配到最后，返回值
      if (j === pattern.length - 1) return i - j
      // 并行
      ++i;
      ++j;
    } else {
      // 复位，主串原位+1，子串归0
      i = i - j + 1
      j = 0
    }
  }
  return -1
}
```

时间复杂度`O(m*n)`。


### KMP的优化思路

针对暴力解，`i`指向主串，`j`指向子串。只要中途不等，`j`将直接归零，`i`将直接在复位+1，然后重新开始匹配。那么是否可以通过某种方法，减少复位的这个极长跨度？

KMP想，每次匹配中途不等短路的时候，其实前面的字符串已经匹配过了。比如：

``` js
'ABA ABAD' // 主串
'ABAD' // 子串
```

那第一次，到`D`的时候，其实已经知道指向`D`的`j`前面全匹配了`ABA`。那我还需要复位进行以下这样的匹配？

| i |   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| - | - | - | - | - | - | - | - | - | - |
| S |   | A | B | A |   | A | B | A | D |
| P |   |   | A | B | A | D |   |   |   |
| j |   |   | 0 | 1 | 2 | 3 |   |   |   |

那是不是有一种办法，让`i`不动，我直接跳`j`:

| i |   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| - | - | - | - | - | - | - | - | - | - |
| S |   | A | B | A |   | A | B | A | D |
| P |   |   |   | A | B | A | D |   |   |
| j |   |   |   | 0 | 1 | 2 | 3 |   |   |

`j`怎么跳？KMP说，跳重复值。什么重复值？以上述为例。第一次中断时，`D`前面是`A`，全字符串是`ABA`。那`j`就往前跳两个`A`之间的距离的跨度，即`j = 3 - 2 = 1`。当然实际情况会更复杂，比如前面是`ABCAB`，那此时应该是重复字符`AB`的跨度。前面是`ABCABDAB`, 此时应该跳到左边第一个`AB`。为什么，因为要保证跳过去之后，前面的字符串`AB`与当前的`ABCABDAB`从右一致。那怎么计算这个跨度呢。KMP搞了个PMT数组，数组长就是子串长，标记了每一个`j`发生中断时，应该往前跳到哪儿。

这个PMT数组我们先不管怎么实现，命名为`pmt = new Array(P.length).fill(-1)`，然后改写一下`match`方法：

``` js
function match(source, pattern) {
  // 双指针
  let i = 0, j = 0;
  while(i < source.length) {
    // 相等
    if (source[i] === pattern[j]) {
      // 匹配到最后，返回值
      if (j === pattern.length - 1) return i - j
      // 并行
      ++i;
      ++j;
    } else {
      if (j === 0) {
        // 第一个都不等，i往前走
        i++;  
      } else {
        // j往前跳
        j = pmt[j]
      }
    }
  }
  return -1
}
```

仔细一看，其实就复位那儿进行了一点骚操作，就省了大半的喝茶时间，完美。

### PMT表格

课上老师讲了种方法：

| a | b | c | d | a | b | c | e |
| - | - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 1 | 2 | 3 | 0 |

理论上是这样的，向右移一位，这样我们可以直接取，不用取的时候还计算加减法`pmt[j - 1]`:

| a | b | c | d | a | b | c | e |
| - | - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 1 | 2 | 3 |

上代码，首尾匹配，匹配成功双进，j的位置表示后缀能匹配多少个前缀：

**其实就是找前缀与后缀相同的最长值**

``` js
function getPmt (pattern) {
  const pmt = new Array(pattern.length).fill(0)
  // 双指针
  let i = 1, j = 0;
  while (i < pattern.length) {
    if (pattern[i] === pattern[j]) {
      i++;
      j++;
      pmt[i] = j; // 此处往右移一位，pmt[i]记录的是i之前的，不包括i的字符串噢
    } else {
      if (j === 0) {
        i++
      } else {
        j = pmt[j] // 此处不是回退至0，因为j之前的字符串可能存在相同后缀数，比如aab，如果j在b处，回退处应该是1。测试：aabaaac
      }
    }
  }
  return pmt
}
```

### Wildcard

模式匹配算法。`?`代表单一字符，`*`代表任意多的字符。

做了一遍之后发现其实有点像KMP。

用递归实现了一次，性能不太好。后面用四个指针重写了。然后结合KMP再重写了一下。主要是pmt表的实现，和普通字符串不一样。不过其实可以看作是几个字符串的pmt表连接在一起而已。
